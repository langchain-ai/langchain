"""Standard, multimodal content blocks for Large Language Model I/O.

.. warning::
    This module is under active development. The API is unstable and subject to
    change in future releases.

This module provides a standardized data structure for representing inputs to and
outputs from Large Language Models. The core abstraction is the **Content Block**, a
``TypedDict`` that can represent a piece of text, an image, a tool call, or other
structured data.

Data **not yet mapped** to a standard block may be represented using the
``NonStandardContentBlock``, which allows for provider-specific data to be included
without losing the benefits of type checking and validation.

Furthermore, provider-specific fields *within* a standard block will be allowed as extra
keys on the TypedDict per `PEP 728 <https://peps.python.org/pep-0728/>`__. This allows
for flexibility in the data structure while maintaining a consistent interface.

**Example using ``extra_items=Any``:**

.. code-block:: python
    from langchain_core.messages.content_blocks import TextContentBlock
    from typing import Any

    my_block: TextContentBlock = {
        "type": "text",
        "text": "Hello, world!",
        "extra_field": "This is allowed",
        "another_field": 42,  # Any type is allowed
    }

    # A type checker that supports PEP 728 would validate the object above.
    # Accessing the provider-specific key is possible, and its type is 'Any'.
    block_extra_field = my_block["extra_field"]

.. warning::
    Type checkers such as MyPy do not yet support `PEP 728 <https://peps.python.org/pep-0728/>`__,
    so you may see type errors when using provider-specific fields. These are safe to
    ignore, as the fields are still validated at runtime.

**Rationale**

Different LLM providers use distinct and incompatible API schemas. This module
introduces a unified, provider-agnostic format to standardize these interactions. A
message to or from a model is simply a `list` of `ContentBlock` objects, allowing for
the natural interleaving of text, images, and other content in a single, ordered
sequence.

An adapter for a specific provider is responsible for translating this standard list of
blocks into the format required by its API.

**Key Block Types**

The module defines several types of content blocks, including:

- **``TextContentBlock``**: Standard text.
- **``ImageContentBlock``**, **``AudioContentBlock``**, **``VideoContentBlock``**: For
    multimodal data.
- **``ToolCallContentBlock``**, **``ToolOutputContentBlock``**: For function calling.
- **``ReasoningContentBlock``**: To capture a model's thought process.
- **``Citation``**: For annotations that link generated text to a source document.

**Example Usage**

.. code-block:: python

    from langchain_core.messages.content_blocks import TextContentBlock, ImageContentBlock

    multimodal_message: AIMessage = [
        TextContentBlock(type="text", text="What is shown in this image?"),
        ImageContentBlock(
            type="image",
            url="https://www.langchain.com/images/brand/langchain_logo_text_w_white.png",
            mime_type="image/png",
        ),
    ]
"""  # noqa: E501

import warnings
from typing import Any, Literal, Union

from pydantic import TypeAdapter, ValidationError
from typing_extensions import NotRequired, TypedDict, get_args, get_origin

# --- Text and annotations ---


class Citation(TypedDict):
    """Annotation for citing data from a document.

    .. note::
        ``start/end`` indices refer to the **response text**,
        not the source text. This means that the indices are relative to the model's
        response, not the original document (as specified in the ``url``).
    """

    type: Literal["citation"]
    """Type of the content block."""

    id: NotRequired[str]
    """Content block identifier. Either:

    - Generated by the provider (e.g., OpenAI's file ID)
    - Generated by LangChain upon creation (as ``UUID4``)
    """

    url: NotRequired[str]
    """URL of the document source."""

    # For future consideration, if needed:
    # provenance: NotRequired[str]
    # """Provenance of the document, e.g., "Wikipedia", "arXiv", etc.

    # Included for future compatibility; not currently implemented.
    # """

    title: NotRequired[str]
    """Source document title.

    For example, the page title for a web page or the title of a paper.
    """

    start_index: NotRequired[int]
    """Start index of the **response text** (``TextContentBlock.text``) for which the
    annotation applies."""

    end_index: NotRequired[int]
    """End index of the **response text** (``TextContentBlock.text``) for which the
    annotation applies."""

    cited_text: NotRequired[str]
    """Excerpt of source text being cited."""

    # NOTE: not including spans for the raw document text (such as `text_start_index`
    # and `text_end_index`) as this is not currently supported by any provider. The
    # thinking is that the `cited_text` should be sufficient for most use cases, and it
    # is difficult to reliably extract spans from the raw document text across file
    # formats or encoding schemes.


class NonStandardAnnotation(TypedDict):
    """Provider-specific annotation format."""

    type: Literal["non_standard_annotation"]
    """Type of the content block."""

    id: NotRequired[str]
    """Content block identifier. Either:

    - Generated by the provider (e.g., OpenAI's file ID)
    - Generated by LangChain upon creation (as ``UUID4``)
    """

    value: dict[str, Any]
    """Provider-specific annotation data."""


Annotation = Union[Citation, NonStandardAnnotation]


class TextContentBlock(TypedDict):
    """Content block for text output.

    This typically represents the main text content of a message, such as the response
    from a language model or the text of a user message.
    """

    type: Literal["text"]
    """Type of the content block."""

    id: NotRequired[str]
    """Content block identifier. Either:

    - Generated by the provider (e.g., OpenAI's file ID)
    - Generated by LangChain upon creation (as ``UUID4``)
    """

    text: str
    """Block text."""

    annotations: NotRequired[list[Annotation]]
    """Citations and other annotations."""


# --- Tool calls ---
class ToolCallContentBlock(TypedDict):
    """Content block for tool calls."""

    type: Literal["tool_call"]
    """Type of the content block."""

    id: NotRequired[str]
    """Content block identifier. Either:

    - Generated by the provider (e.g., OpenAI's file ID)
    - Generated by LangChain upon creation (as ``UUID4``)
    """

    name: str
    """The name of the tool to be called."""

    args: dict[str, Any]
    """The arguments for the tool, as a dictionary."""

    call_id: str
    """The unique ID for this tool call."""


# --- Provider tool calls (built-in tools) ---
# Note: These are not standard tool calls, but rather provider-specific built-in tools.


# Web search
class SearchCall(TypedDict):
    """Content block for a built-in web search tool call."""

    type: Literal["search_call"]
    """Type of the content block."""

    id: NotRequired[str]
    """Content block identifier. Either:

    - Generated by the provider (e.g., OpenAI's file ID)
    - Generated by LangChain upon creation (as ``UUID4``)
    """

    query: NotRequired[str]
    """The search query used in the web search tool call."""


class SearchResult(TypedDict):
    """Content block for the result of a built-in search tool call."""

    type: Literal["search_result"]
    """Type of the content block."""

    id: NotRequired[str]
    """Content block identifier. Either:

    - Generated by the provider (e.g., OpenAI's file ID)
    - Generated by LangChain upon creation (as ``UUID4``)
    """

    urls: NotRequired[list[str]]
    """List of URLs returned by the web search tool call."""


# Code interpreter


# Call
class CodeInterpreterCall(TypedDict):
    """Content block for a built-in code interpreter tool call."""

    type: Literal["code_interpreter_call"]
    """Type of the content block."""

    id: NotRequired[str]
    """Content block identifier. Either:

    - Generated by the provider (e.g., OpenAI's file ID)
    - Generated by LangChain upon creation (as ``UUID4``)
    """

    language: NotRequired[str]
    """The programming language used in the code interpreter tool call."""

    code: NotRequired[str]
    """The code to be executed by the code interpreter."""


# Result block is CodeInterpreterResult
class CodeInterpreterOutput(TypedDict):
    """Content block for the output of a singular code interpreter tool call.

    Full output of a code interpreter tool call is represented by
    ``CodeInterpreterResult`` which is a list of these blocks.
    """

    type: Literal["code_interpreter_output"]
    """Type of the content block."""

    id: NotRequired[str]
    """Content block identifier. Either:

    - Generated by the provider (e.g., OpenAI's file ID)
    - Generated by LangChain upon creation (as ``UUID4``)
    """

    return_code: NotRequired[int]
    """Return code of the executed code.

    Example: 0 for success, non-zero for failure.
    """

    stderr: NotRequired[str]
    """Standard error output of the executed code."""

    stdout: NotRequired[str]
    """Standard output of the executed code."""

    file_ids: NotRequired[list[str]]
    """List of file IDs generated by the code interpreter."""


class CodeInterpreterResult(TypedDict):
    """Content block for the result of a code interpreter tool call."""

    type: Literal["code_interpreter_result"]
    """Type of the content block."""

    id: NotRequired[str]
    """Content block identifier. Either:

    - Generated by the provider (e.g., OpenAI's file ID)
    - Generated by LangChain upon creation (as ``UUID4``)
    """

    output: list[CodeInterpreterOutput]
    """List of outputs from the code interpreter tool call."""


# --- Reasoning ---
class ReasoningContentBlock(TypedDict):
    """Content block for reasoning output."""

    type: Literal["reasoning"]
    """Type of the content block."""

    id: NotRequired[str]
    """Content block identifier. Either:

    - Generated by the provider (e.g., OpenAI's file ID)
    - Generated by LangChain upon creation (as ``UUID4``)
    """

    reasoning: NotRequired[str]
    """Reasoning text.

    Either the thought summary or the raw reasoning text itself. This is often parsed
    from ``<think>`` tags in the model's response.
    """

    thought_signature: NotRequired[str]
    """Opaque state handle representation of the model's internal thought process.

    Maintains the context of the model's thinking across multiple interactions
    (e.g. multi-turn conversations) since many APIs are stateless.

    Not to be used to verify authenticity or integrity of the response (`'signature'`).

    Examples:
    - https://ai.google.dev/gemini-api/docs/thinking#signatures
    """

    signature: NotRequired[str]
    """Signature of the reasoning content block used to verify **authenticity**.

    Prevents from modifying or fabricating the model's reasoning process.

    Examples:
    - https://docs.anthropic.com/en/docs/build-with-claude/context-windows#the-context-window-with-extended-thinking-and-tool-use
    """


# --- Multi-modal ---


# Note: `title` and `context` are fields that could be used to provide additional
# information about the file, such as a description or summary of its content.
# E.g. with Claude, you can provide a context for a file which is passed to the model.
class ImageContentBlock(TypedDict):
    """Content block for image data."""

    type: Literal["image"]
    """Type of the content block."""

    id: NotRequired[str]
    """Content block identifier. Either:

    - Generated by the provider (e.g., OpenAI's file ID)
    - Generated by LangChain upon creation (as ``UUID4``)
    """

    file_id: NotRequired[str]
    """ID of the image file, e.g., from a file storage system."""

    mime_type: NotRequired[str]
    """MIME type of the image. Required for base64.

    `Examples from IANA <https://www.iana.org/assignments/media-types/media-types.xhtml#image>`__
    """

    url: NotRequired[str]
    """URL of the image."""

    base64: NotRequired[str]
    """Data as a base64 string."""

    # title: NotRequired[str]
    # """Title of the image."""

    # context: NotRequired[str]
    # """Context for the image, e.g., a description or summary of the image's content."""  # noqa: E501


class VideoContentBlock(TypedDict):
    """Content block for video data."""

    type: Literal["video"]
    """Type of the content block."""

    id: NotRequired[str]
    """Content block identifier. Either:

    - Generated by the provider (e.g., OpenAI's file ID)
    - Generated by LangChain upon creation (as ``UUID4``)
    """

    file_id: NotRequired[str]
    """ID of the video file, e.g., from a file storage system."""

    mime_type: NotRequired[str]
    """MIME type of the video. Required for base64.

    `Examples from IANA <https://www.iana.org/assignments/media-types/media-types.xhtml#video>`__
    """

    url: NotRequired[str]
    """URL of the video."""

    base64: NotRequired[str]
    """Data as a base64 string."""

    # title: NotRequired[str]
    # """Title of the video."""

    # context: NotRequired[str]
    # """Context for the video, e.g., a description or summary of the video's content.""" # noqa: E501


class AudioContentBlock(TypedDict):
    """Content block for audio data."""

    type: Literal["audio"]
    """Type of the content block."""

    id: NotRequired[str]
    """Content block identifier. Either:

    - Generated by the provider (e.g., OpenAI's file ID)
    - Generated by LangChain upon creation (as ``UUID4``)
    """

    file_id: NotRequired[str]
    """ID of the audio file, e.g., from a file storage system."""

    mime_type: NotRequired[str]
    """MIME type of the audio. Required for base64.

    `Examples from IANA <https://www.iana.org/assignments/media-types/media-types.xhtml#audio>`__
    """

    url: NotRequired[str]
    """URL of the audio."""

    base64: NotRequired[str]
    """Data as a base64 string."""

    # title: NotRequired[str]
    # """Title of the audio."""

    # context: NotRequired[str]
    # """Context for the audio, e.g., a description or summary of the audio's content.""" # noqa: E501


class PlainTextContentBlock(TypedDict):
    """Content block for plaintext data (e.g., from a document).

    .. note::
        Title and context are optional fields that may be passed to the model. See
        Anthropic `example <https://docs.anthropic.com/en/docs/build-with-claude/citations#citable-vs-non-citable-content>`__.
    """

    type: Literal["text-plain"]
    """Type of the content block."""

    id: NotRequired[str]
    """Content block identifier. Either:

    - Generated by the provider (e.g., OpenAI's file ID)
    - Generated by LangChain upon creation (as ``UUID4``)
    """

    file_id: NotRequired[str]
    """ID of the plaintext file, e.g., from a file storage system."""

    mime_type: Literal["text/plain"]
    """MIME type of the file. Required for base64."""

    url: NotRequired[str]
    """URL of the plaintext."""

    base64: NotRequired[str]
    """Data as a base64 string."""

    text: NotRequired[str]
    """Plaintext content. This is optional if the data is provided as base64."""

    title: NotRequired[str]
    """Title of the text data, e.g., the title of a document."""

    context: NotRequired[str]
    """Context for the text, e.g., a description or summary of the text's content."""


class FileContentBlock(TypedDict):
    """Content block for file data.

    This block is intended for files that are not images, audio, or plaintext. For
    example, it can be used for PDFs, Word documents, etc.

    If the file is an image, audio, or plaintext, you should use the corresponding
    content block type (e.g., ``ImageContentBlock``, ``AudioContentBlock``,
    ``PlainTextContentBlock``).
    """

    type: Literal["file"]
    """Type of the content block."""

    id: NotRequired[str]
    """Content block identifier. Either:

    - Generated by the provider (e.g., OpenAI's file ID)
    - Generated by LangChain upon creation (as ``UUID4``)
    """

    file_id: NotRequired[str]
    """ID of the file, e.g., from a file storage system."""

    mime_type: NotRequired[str]
    """MIME type of the file. Required for base64.

    `Examples from IANA <https://www.iana.org/assignments/media-types/media-types.xhtml>`__
    """

    url: NotRequired[str]
    """URL of the file."""

    base64: NotRequired[str]
    """Data as a base64 string."""

    # title: NotRequired[str]
    # """Title of the file, e.g., the name of a document or file."""

    # context: NotRequired[str]
    # """Context for the file, e.g., a description or summary of the file's content."""


# Future modalities to consider:
# - 3D models
# - Tabular data


# Non-standard
class NonStandardContentBlock(TypedDict):
    """Content block provider-specific data.

    This block contains data for which there is not yet a standard type.

    The purpose of this block should be to simply hold a provider-specific payload.
    If a provider's non-standard output includes reasoning and tool calls, it should be
    the adapter's job to parse that payload and emit the corresponding standard
    ReasoningContentBlock and ToolCallContentBlocks.
    """

    type: Literal["non_standard"]
    """Type of the content block."""

    id: NotRequired[str]
    """Content block identifier. Either:

    - Generated by the provider (e.g., OpenAI's file ID)
    - Generated by LangChain upon creation (as ``UUID4``)
    """

    value: dict[str, Any]
    """Provider-specific data."""


# --- Aliases ---
DataContentBlock = Union[
    ImageContentBlock,
    VideoContentBlock,
    AudioContentBlock,
    PlainTextContentBlock,
    FileContentBlock,
]

ToolContentBlock = Union[
    ToolCallContentBlock,
    CodeInterpreterCall,
    CodeInterpreterOutput,
    CodeInterpreterResult,
    SearchCall,
    SearchResult,
]

ContentBlock = Union[
    TextContentBlock,
    ToolCallContentBlock,
    ReasoningContentBlock,
    NonStandardContentBlock,
    DataContentBlock,
    ToolContentBlock,
]


def _extract_typedict_type_values(union_type: Any) -> set[str]:
    """Extract the values of the 'type' field from a TypedDict union type."""
    result: set[str] = set()
    for value in get_args(union_type):
        annotation = value.__annotations__["type"]
        if get_origin(annotation) is Literal:
            result.update(get_args(annotation))
        else:
            msg = f"{value} 'type' is not a Literal"
            raise ValueError(msg)
    return result


KNOWN_BLOCK_TYPES = {
    bt for bt in get_args(ContentBlock) for bt in get_args(bt.__annotations__["type"])
}

# Adapter for DataContentBlock
_DataAdapter: TypeAdapter[DataContentBlock] = TypeAdapter(DataContentBlock)


def is_data_content_block(block: dict) -> bool:
    """Check if the content block is a standard data content block.

    Args:
        block: The content block to check.

    Returns:
        True if the content block is a data content block, False otherwise.
    """
    try:
        _DataAdapter.validate_python(block)
    except ValidationError:
        return False
    else:
        return True


# TODO: don't use `source_type` anymore
def convert_to_openai_image_block(content_block: dict[str, Any]) -> dict:
    """Convert image content block to format expected by OpenAI Chat Completions API."""
    if content_block["source_type"] == "url":
        return {
            "type": "image_url",
            "image_url": {
                "url": content_block["url"],
            },
        }
    if content_block["source_type"] == "base64":
        if "mime_type" not in content_block:
            error_message = "mime_type key is required for base64 data."
            raise ValueError(error_message)
        mime_type = content_block["mime_type"]
        return {
            "type": "image_url",
            "image_url": {
                "url": f"data:{mime_type};base64,{content_block['data']}",
            },
        }
    error_message = "Unsupported source type. Only 'url' and 'base64' are supported."
    raise ValueError(error_message)


def convert_to_openai_data_block(block: dict) -> dict:
    """Format standard data content block to format expected by OpenAI."""
    if block["type"] == "image":
        formatted_block = convert_to_openai_image_block(block)

    elif block["type"] == "file":
        if block["source_type"] == "base64":
            file = {"file_data": f"data:{block['mime_type']};base64,{block['data']}"}
            if filename := block.get("filename"):
                file["filename"] = filename
            elif (metadata := block.get("metadata")) and ("filename" in metadata):
                file["filename"] = metadata["filename"]
            else:
                warnings.warn(
                    "OpenAI may require a filename for file inputs. Specify a filename "
                    "in the content block: {'type': 'file', 'source_type': 'base64', "
                    "'mime_type': 'application/pdf', 'data': '...', "
                    "'filename': 'my-pdf'}",
                    stacklevel=1,
                )
            formatted_block = {"type": "file", "file": file}
        elif block["source_type"] == "id":
            formatted_block = {"type": "file", "file": {"file_id": block["id"]}}
        else:
            error_msg = "source_type base64 or id is required for file blocks."
            raise ValueError(error_msg)

    elif block["type"] == "audio":
        if block["source_type"] == "base64":
            audio_format = block["mime_type"].split("/")[-1]
            formatted_block = {
                "type": "input_audio",
                "input_audio": {"data": block["data"], "format": audio_format},
            }
        else:
            error_msg = "source_type base64 is required for audio blocks."
            raise ValueError(error_msg)
    else:
        error_msg = f"Block of type {block['type']} is not supported."
        raise ValueError(error_msg)

    return formatted_block
