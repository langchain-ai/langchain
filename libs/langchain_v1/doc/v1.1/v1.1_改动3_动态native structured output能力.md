# v1.1_改动3_动态native structured output能力.md

一句话总结： 不需要手动为 “哪些模型能 native structured output” 写白名单或条件分支：LangChain 会依据 profile 自动决定。

## 曾经

以往你需要根据模型能力来手动指定用 **ProviderStrategy** 还是 **ToolStrategy**。也就是说，要“白名单模型用 ProviderStrategy，其余用 ToolStrategy”。

让 agent 输出结构化数据（如 JSON、Pydantic、dataclass、TypedDict 等），以往通常有两种方式：

### 1. ProviderStrategy

> **适用条件**：模型 profile 标记支持 `structured_output`

- 直接利用模型的原生 structured output 能力（如 OpenAI GPT-4o、Claude 等部分模型官方支持 JSON/Object 输出格式）。
- **优点**：高效、直接，无需额外指令工程或工具桥接，输出质量最好。
- **原理**：直接让模型返回结构化内容，由 LangChain 解析。

### 2. ToolStrategy

- 如果模型本身不支持原生结构化输出，就用更通用的 ToolStrategy。
- **方式**：在模型前增加中间层（如工具调用、函数调用 prompt 等），引导模型返回结构化数据。
- **优缺点**：适用面更广，但没有 ProviderStrategy 那么高效和精准。

整理说明如下：

1. **定义结构化数据模型**

```python
class PersonInfo(BaseModel):
    name: str
    age: int
    email: str
```

2. **通过 ToolStrategy 提供给 agent**

- 使用 `ToolStrategy(PersonInfo)` 配置 agent，使其能基于该结构化模型进行信息抽取。

3. **Agent 交互过程**

- **输入给 LLM：**

  ```
  System / context: Available tool: PersonInfo(name: string, age: integer, email: string)
  User: Please extract the person's info from: "Alice, 30 years old, email alice@example.com"
  ```

- **LLM 输出（非纯文本，而是 tool call 格式）：**

  ```json
  {
    "tool_calls": [
      {
        "name": "PersonInfo",
        "arguments": {
           "name": "Alice",
           "age": 30,
           "email": "alice@example.com"
        },
        "id": "call_123"
      }
    ],
    "content": ""
  }
  ```

4. **LangChain 自动处理**

- 检测到有 tool_call，自动将 arguments 解析为结构化对象：

  ```python
  PersonInfo(name="Alice", age=30, email="alice@example.com")
  ```

5. **返回结构化响应**

- agent.invoke 的典型返回结构：

  ```python
  {
    "messages": [ ...conversation + assistant message referencing tool call... ],
    "structured_response": PersonInfo(name="Alice", age=30, email="alice@example.com")
  }
  ```

- 你可以直接使用 `structured_response` 进行数据库存储、API 返回或前端序列化等后续处理。

## 当前机制概述

- 在 langchain 1.1 及以上版本，每个聊天模型实例都包含 `.profile` 属性（一个 dict），用于描述该模型的能力。比如 `"structured_output": true` 表示模型支持结构化输出。
- 使用 `create_agent` 并通过 `response_format` 参数传入 schema 类型（如 Pydantic 类）时，LangChain 会自动读取模型的 `.profile`，判断其是否支持原生结构化输出。
  - 如果 `.profile` 中标注 `native structured_output`，则会采用 ProviderStrategy（原生结构化输出）。
  - 否则，则自动回退到 ToolStrategy（即将结构化任务作为工具调用解决）。

## 在代码中如何体现 / 如何使用

```py
from langchain import init_chat_model
from langchain.agents import create_agent
from pydantic import BaseModel, Field

class MySchema(BaseModel):
    name: str
    age: int

# 初始化一个模型 (假设模型支持 structured output)
model = init_chat_model("some-model-id")

agent = create_agent(
    model=model,
    # ...
    response_format=MySchema  # 传入 schema 类型
)

# LangChain 会自动检查 model.profile["structured_output"]
# 如果为 True，就使用 ProviderStrategy
# 如果为 False / 不存在，就退回 ToolStrategy

# 手动覆盖
custom_profile = {
    **model.profile,
    "structured_output": True,
}
model2 = model.model_copy(update={"profile": custom_profile})
# 即使 upstream profile 数据不完整，你也可以手动强制启用 native structured output

```


## ProviderStrategy源码解释

### 1. ProviderStrategy 类定义

```python
# langchain/agents/structured_output.py

@dataclass(init=False)
class ProviderStrategy(Generic[SchemaT]):
    """Use the model provider's native structured output method."""

    schema: type[SchemaT]
    """Schema for native mode."""

    schema_spec: _SchemaSpec[SchemaT]
    """Schema spec for native mode."""

    def __init__(self, schema: type[SchemaT]) -> None:
        """Initialize ProviderStrategy with schema."""
        self.schema = schema
        self.schema_spec = _SchemaSpec(schema)

    def to_model_kwargs(self) -> dict[str, Any]:
        """Convert to kwargs to bind to a model to force structured output."""
        # OpenAI 格式的 response_format
        response_format = {
            "type": "json_schema",
            "json_schema": {
                "name": self.schema_spec.name,
                "schema": self.schema_spec.json_schema,
            },
        }
        return {"response_format": response_format}
```

**要点解释：**
- `schema`：用户传入的结构化数据类型（Pydantic / dataclass / TypedDict / JSON schema dict）
- `schema_spec`：内部包装，自动提取 name、description、json_schema 等元信息
- `to_model_kwargs()`：生成传给模型的参数，使用 OpenAI 标准的 `response_format` 格式

### 2. 自动检测模型是否支持 ProviderStrategy

```python
# langchain/agents/factory.py

def _supports_provider_strategy(model: str | BaseChatModel, tools: list | None = None) -> bool:
    """Check if a model supports provider-specific structured output."""
    model_name: str | None = None
    if isinstance(model, str):
        model_name = model
    elif isinstance(model, BaseChatModel):
        model_name = (
            getattr(model, "model_name", None)
            or getattr(model, "model", None)
            or getattr(model, "model_id", "")
        )
        model_profile = model.profile  # ← 关键：读取模型的 .profile 属性
        if (
            model_profile is not None
            and model_profile.get("structured_output")  # ← 检查是否支持结构化输出
            # Gemini 模型例外：不支持 tool_calling + structured_output 同时使用
            and not (tools and isinstance(model_name, str) and "gemini" in model_name.lower())
        ):
            return True

    # 回退逻辑：白名单模型（gpt-4o、o3-mini 等）
    return (
        any(part in model_name.lower() for part in FALLBACK_MODELS_WITH_STRUCTURED_OUTPUT)
        if model_name
        else False
    )
```

**检测流程：**
1. 读取 `model.profile["structured_output"]`
2. 如果为 `True` → 支持 ProviderStrategy
3. Gemini 特殊处理：有工具时不能用 ProviderStrategy
4. 回退：硬编码的白名单模型列表

### 3. AutoStrategy 自动选择策略

```python
# langchain/agents/factory.py - _get_bound_model 函数内部

# Determine effective response format (auto-detect if needed)
effective_response_format: ResponseFormat | None
if isinstance(request.response_format, AutoStrategy):
    # 用户传入的是 AutoStrategy（或直接传 schema 类型）
    if _supports_provider_strategy(request.model, tools=request.tools):
        # 模型支持原生结构化输出 → 使用 ProviderStrategy
        effective_response_format = ProviderStrategy(schema=request.response_format.schema)
    else:
        # 模型不支持 → 回退到 ToolStrategy
        effective_response_format = ToolStrategy(schema=request.response_format.schema)
else:
    # 用户显式指定了策略 → 直接使用
    effective_response_format = request.response_format
```

**自动选择逻辑：**
- 当你直接传 `response_format=MySchema` 时，会被包装为 `AutoStrategy(MySchema)`
- LangChain 根据 `_supports_provider_strategy()` 判断结果自动选择策略
- 你也可以显式传 `ProviderStrategy(MySchema)` 或 `ToolStrategy(MySchema)` 强制使用某种策略

### 4. ProviderStrategy 绑定模型的过程

```python
# langchain/agents/factory.py - _get_bound_model 函数内部

if isinstance(effective_response_format, ProviderStrategy):
    # 获取 OpenAI 格式的 response_format 参数
    kwargs = effective_response_format.to_model_kwargs()
    # 绑定到模型，strict=True 表示严格模式
    return (
        request.model.bind_tools(
            final_tools, strict=True, **kwargs, **request.model_settings
        ),
        effective_response_format,
    )
```

**绑定过程：**
1. 调用 `to_model_kwargs()` 获取 `{"response_format": {...}}`
2. 通过 `model.bind_tools()` 将参数绑定到模型
3. `strict=True` 确保模型严格按照 schema 输出

### 5. ProviderStrategyBinding 解析模型输出

```python
# langchain/agents/structured_output.py

@dataclass
class ProviderStrategyBinding(Generic[SchemaT]):
    """Information for tracking native structured output metadata."""

    schema: type[SchemaT]
    schema_kind: SchemaKind  # "pydantic" | "dataclass" | "typeddict" | "json_schema"

    def parse(self, response: AIMessage) -> SchemaT:
        """Parse AIMessage content according to the schema."""
        # 1. 从 AIMessage 提取文本内容
        raw_text = self._extract_text_content_from_message(response)

        # 2. 解析 JSON
        import json
        try:
            data = json.loads(raw_text)
        except Exception as e:
            raise ValueError(f"Native structured output expected valid JSON...")

        # 3. 根据 schema 类型转换为对应的 Python 对象
        return _parse_with_schema(self.schema, self.schema_kind, data)
```

**解析流程：**
1. 从 `AIMessage.content` 提取原始 JSON 文本
2. `json.loads()` 解析为 dict
3. `_parse_with_schema()` 根据 schema_kind 转换为目标类型（Pydantic 实例 / dataclass 实例等）

### 6. 完整数据流图

```
用户传入 response_format=MySchema
              │
              ▼
      包装为 AutoStrategy(MySchema)
              │
              ▼
    _supports_provider_strategy(model) 检测
              │
      ┌───────┴───────┐
      │               │
   支持            不支持
      │               │
      ▼               ▼
ProviderStrategy  ToolStrategy
      │               │
      ▼               ▼
model.bind(         model.bind_tools(
  response_format=   tools=[MySchema工具],
  {...json_schema}   tool_choice="any"
)                 )
      │               │
      ▼               ▼
模型返回纯JSON   模型返回 tool_calls
      │               │
      ▼               ▼
ProviderStrategy  OutputToolBinding
Binding.parse()   .parse(tool_args)
      │               │
      └───────┬───────┘
              │
              ▼
    structured_response = MySchema实例
```

### 7. 关键设计总结

| 组件 | 作用 |
|------|------|
| `model.profile["structured_output"]` | 模型能力标记，决定是否启用原生输出 |
| `AutoStrategy` | 自动选择策略的包装器 |
| `ProviderStrategy` | 使用模型原生 structured output 能力 |
| `ToolStrategy` | 通过工具调用模拟 structured output |
| `_supports_provider_strategy()` | 检测函数，读取 profile 判断 |
| `ProviderStrategyBinding.parse()` | 解析原生 JSON 输出为 schema 实例 |

这样的设计使得开发者只需传入 schema，LangChain 会根据模型能力自动选择最优策略，无需关心底层实现细节。